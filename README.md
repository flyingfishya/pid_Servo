# pid_Servo
基于stm32和舵机的pid控制，代码可以用于参考2023年电赛题目。
这边lvse.zip文件中包含绿光追踪红光的绿光舵机部分的pid控制代码，
由于考虑到放置位置的偏移所以采用3个模式对应3种不同的pid来调节绿色光对红色光的追踪。
红色分为，v831和树莓派两种，如果采用v831官方发布的一个模型进行红光和黑色外框追踪的话由于模型它输出的是字符型我在该代码里面对这个字符串进行了处理，
用以接收红光和外框 的点位，树莓派版本的也是这个做法但是树莓派是使用opencv自定义协议所以协议上简单。
上方红光的画框原理是获取红色光的点位，和外框的四个角的点位，然后通过pid对每个点和红光进行重合，以达到画框，但是这个过程两点有段距离，
为防止中间部分出现问题我将获取到的四个点每个点之间进行类似“模糊pid”的方法按顺序接收到的每两个点坐标之间我将其看作x个点这个x我取用了4，
举个简单例子，例如两个点为x1，y1，x2,y2 先对x1,x2进行判断看两者之间是否差超过10个像素点（根据实际情况而定不同摄像头和方法取值不同）我们可以得出：
1.如果超过的话x就不是两个相同的值保留x1，x2;
2.如果不超过将x看作相同的值并取平均值得出x= x1+x2;
之后以此类推可以得出y的结论。
然后其实你就可以判断出来这两个点的姿态，因为吧两个无非就是一条线段（当然因为曲线是可以看作是很多个线段组成，视觉返回的两个点之间肯定是要处理成线段两端）
那么剩下的姿态就只剩下三种可能：
1.平行的线段;
2.竖直的线段;
3.斜线;
其中斜线也分很多个方向和姿态，但是这个可以不要管，因为使用的方法完全不影响结果。
接下来如果是
1.平行的：我们只要将y固定因为在这里y1,y2相差就不会超过10就得出了y,将x_0 = (x2 - x1)/4,  x1,  x_1=x1+x_0,  x_2 =x1+2x_0,  x_3 =x1+3x_0,  x2;
然后采用红光对x1, x_1, x_2, x_3, x2;进行按顺序的对每两点之间进行pid调节;
2.竖直的：x，y的处理和平行的互换就行;进行按顺序的对每两点之间进行pid调节;
3.斜线：同时对x，y都采用平行中的x的处理方法进行处理得出x_1,y_1一类就行;进行按顺序的对每两点之间进行pid调节;
以上就是大致的方法和思路。
